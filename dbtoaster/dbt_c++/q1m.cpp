#include <iostream>
#include "q1m.hpp"
#include <chrono>
namespace dbtoaster{
    class CustomProgram_1 : public Program
    {
    public:
        void process_stream_event(const event_t& ev) {
            //cout << "on_" << dbtoaster::event_name[ev.type] << "_";
            // cout << get_relation_name(ev.id) << "(" << ev.data << ")" << endl;

            Program::process_stream_event(ev);
        }
    };

    class CustomProgram_2 : public Program
    {
    public:
//		CustomProgram_2(int argc = 0, char* argv[] = 0) : Program(argc,argv) {}
        void process_streams() {
			Program::process_streams();
			int MAX = 50000;
			long X = 1000000000;
			{//PT
				std::string line;
				ifstream tweet("/home/ucsd/gaurav/dbtoaster/examples/data/fastviewmixed/tweet.csv");
				std::string delimiter = ",";
				std::string* a[3];
				int i = 0;
				while ( getline (myfile,line) ) {
					size_t pos = 0;
					std::string token;
					while ((pos = line.find(delimiter)) != std::string::npos) {
					    token = line.substr(0, pos);
					    a[i++] = token;
					    line.erase(0, pos + delimiter.length());
					}
					data.on_insert_TWEET(
				}
				for( long i = 1; i <= MAX; ++i ) {
					const STRING_TYPE *s = new STRING_TYPE("2992-01-01");
                                        data.on_insert_TWEET(2, X + i, *s);
                                }
                                const auto start_time = std::chrono::steady_clock::now();
                                for( long i = 1; i <= MAX; ++i ) {
					const STRING_TYPE *s = new STRING_TYPE("2992-01-01");
                                        data.on_delete_TWEET(2, X + i, *s);
                                }
                                double time_in_seconds = std::chrono::duration_cast<std::chrono::milliseconds> (std::chrono::steady_clock::now() - start_time).count();
                                std::cout << time_in_seconds<<"ms"<<std::endl;
			}
        }
    };
}


/**
 * In order to compile this file one would have to include a header containing
 * the definition of "dbtoaster::Program" and "dbtoaster::Program::snapshot_t"
 * as generated by the dbtoaster C++ code generator. Using the "-c" dbtoaster
 * command line option the generated header file is automatically included and
 * compiled against this file.
 */

/**
 * Determines whether "--async" was specified as a command line argument.
 *
 * @param argc
 * @param argv
 * @return true if "--async" is one of the command line arguments
 */
bool async_mode(int argc, char* argv[])
{
    for(int i = 1; i < argc; ++i)
        if( !strcmp(argv[i],"--async") )
            return true;
    return false;
}

/**
 * Main function that executes the sql program corresponding to the header file
 * included. If "-async" is among the command line arguments then the execution
 * is performed asynchronous in a seperate thread, otherwise it is performed in
 * the same thread. If performed in a separate thread and while not finished it
 * continuously gets snapshots of the results and prints them in xml format. At
 * the end of the execution the final results are also printed.
 *
 * @param argc
 * @param argv
 * @return
 */
int main(int argc, char* argv[]) {
    bool async = async_mode(argc,argv);

    //dbtoaster::Program p;//(argc,argv);
    //dbtoaster::CustomProgram_1 p;
    dbtoaster::CustomProgram_2 p;
    //dbtoaster::Program::snapshot_t snap;
	dbtoaster::CustomProgram_2::snapshot_t snap;

    cout << "Initializing program:" << endl;
    p.init();
	
    p.run( async );

    cout << "Running program:" << endl;
    while( !p.is_finished() )
    {
       snap = p.get_snapshot();
       DBT_SERIALIZATION_NVP_OF_PTR(cout, snap);
    }

    cout << "Printing final result:" << endl;
    snap = p.get_snapshot();
    //DBT_SERIALIZATION_NVP_OF_PTR(cout, snap);
    cout << std::endl;
    return 0;
}
