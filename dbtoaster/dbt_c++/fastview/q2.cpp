#include "q2.hpp"
#include <chrono>
namespace dbtoaster{
    class CustomProgram_1 : public Program
    {
    public:
        void process_stream_event(const event_t& ev) {
			cout<<"Staring segfault...2"<<endl;
            //cout << "on_" << dbtoaster::event_name[ev.type] << "_";
            // cout << get_relation_name(ev.id) << "(" << ev.data << ")" << endl;

            //Program::process_stream_event(ev);
        }
    };

    class CustomProgram_2 : public Program
    {
    public:
        void process_streams() {
			Program::process_streams();
			int which = 1;
			if(which  == 2) {
				int MAX = 50000;
				long X = 1000000000;
				//long *u = new long(100);
				//for(long j = 1; j <= 3; j++) {
				//	long *f1 = new long(j);
				//	data.on_insert_FOLLOWER(*u, *f1);
				//}
                                for( long i = 1; i <= MAX; ++i ) {
                                        const STRING_TYPE *s = new STRING_TYPE("2992-01-01");
                                        const long *u = new long(100);
                                        const long *t = new long(X + i);
                                        data.on_insert_TWEET(*u, *t, *s);
                                }
				const auto start_time = std::chrono::steady_clock::now();
				for( long i = 1; i <= MAX; ++i ) {
					const STRING_TYPE *s = new STRING_TYPE("2992-01-01");
					const long *u = new long(100);
					const long *t = new long(X + i);
					data.on_delete_TWEET(*u, *t, *s);
				}
				double time_in_seconds = std::chrono::duration_cast<std::chrono::milliseconds> (std::chrono::steady_clock::now() - start_time).count();
			std::cout << time_in_seconds<<"ms"<<std::endl;
			}
			if(which == 1) {
                                int MAX = 50000;
                                long X = -1000000000;

                                for( long i = 1; i <= MAX; ++i ) {
					long *u = new long(X + i);
					for(long j = 1; j <= 5; j++) {
						long *f1 = new long(j);
						data.on_insert_FOLLOWER(*u, *f1);
					}
				}
                                for( long i = 1; i <= MAX; ++i ) {
                                        const STRING_TYPE *s = new STRING_TYPE("2992-01-01");
                                        const long *u = new long(X + i);
                                        const long *t = new long(X + i);
                                        data.on_insert_TWEET(*u, *t, *s);
                                }
                                const auto start_time = std::chrono::steady_clock::now();
                                for( long i = 1; i <= MAX; ++i ) {
                                        const STRING_TYPE *s = new STRING_TYPE("2992-01-01");
                                        const long *u = new long(X + i);
                                        const long *t = new long(X + i);
                                        data.on_delete_TWEET(*u, *t, *s);
                                }
                                double time_in_seconds = std::chrono::duration_cast<std::chrono::milliseconds> (std::chrono::steady_clock::now() - start_time).count();
                        std::cout << time_in_seconds<<"ms"<<std::endl;
			}

        }
    };
}


/**
 * In order to compile this file one would have to include a header containing
 * the definition of "dbtoaster::Program" and "dbtoaster::Program::snapshot_t"
 * as generated by the dbtoaster C++ code generator. Using the "-c" dbtoaster
 * command line option the generated header file is automatically included and
 * compiled against this file.
 */

/**
 * Determines whether "--async" was specified as a command line argument.
 *
 * @param argc
 * @param argv
 * @return true if "--async" is one of the command line arguments
 */
bool async_mode(int argc, char* argv[])
{
    for(int i = 1; i < argc; ++i)
        if( !strcmp(argv[i],"--async") )
            return true;
    return false;
}

/**
 * Main function that executes the sql program corresponding to the header file
 * included. If "-async" is among the command line arguments then the execution
 * is performed asynchronous in a seperate thread, otherwise it is performed in
 * the same thread. If performed in a separate thread and while not finished it
 * continuously gets snapshots of the results and prints them in xml format. At
 * the end of the execution the final results are also printed.
 *
 * @param argc
 * @param argv
 * @return
 */
int main(int argc, char* argv[]) {
    bool async = async_mode(argc,argv);

    //dbtoaster::Program p;//(argc,argv);
    //dbtoaster::CustomProgram_1 p;
    dbtoaster::CustomProgram_2 p;
    //dbtoaster::Program::snapshot_t snap;
	dbtoaster::CustomProgram_2::snapshot_t snap;

    cout << "Initializing program:" << endl;
    p.init();
	
    p.run( async );

    cout << "Running program:" << endl;
    while( !p.is_finished() )
    {
       snap = p.get_snapshot();
       DBT_SERIALIZATION_NVP_OF_PTR(cout, snap);
    }
    cout << "Printing final result:" << endl;
    snap = p.get_snapshot();
    //DBT_SERIALIZATION_NVP_OF_PTR(cout, snap);
    cout << std::endl;
    return 0;
}

