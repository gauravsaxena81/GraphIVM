#include "q3Agg.hpp"
#include <chrono>
namespace dbtoaster{
    class CustomProgram_1 : public Program
    {
    public:
        void process_stream_event(const event_t& ev) {
            //cout << "on_" << dbtoaster::event_name[ev.type] << "_";
            // cout << get_relation_name(ev.id) << "(" << ev.data << ")" << endl;

            Program::process_stream_event(ev);
        }
    };

    class CustomProgram_2 : public Program
    {
    public:
//		CustomProgram_2(int argc = 0, char* argv[] = 0) : Program(argc,argv) {}
        void process_streams() {
			Program::process_streams();
			int which = 2;
			int MAX = 50000;
			long X = 1000000000;
			if(which == 2) {//JT
				const STRING_TYPE *s = new STRING_TYPE("2992-01-01");
				data.on_insert_USERS(X);
				for( long i = 1; i <= MAX; ++i ) {
                                        data.on_insert_TWEET(X, X + i, *s);
                                }
                                for( long i = 1; i <= MAX; ++i ) {
					//data.on_insert_RETWEET(X + i, X + i, *s, X + i);
                                }
				const auto start_time = std::chrono::steady_clock::now();
				for( long i = 1; i <= MAX; ++i ) {
					data.on_insert_RETWEET(X + i, X + i, *s, X + i);
					//data.on_delete_RETWEET(X + i, X + i, *s, X + i);
				}
				double time_in_seconds = std::chrono::duration_cast<std::chrono::milliseconds> (std::chrono::steady_clock::now() - start_time).count();
				std::cout << time_in_seconds<<"ms"<<std::endl;
				api.print();
			}
                        if(which == 1) {//PT
                                const STRING_TYPE *s = new STRING_TYPE("2992-01-01");
                                for( long i = 1; i <= MAX; ++i ) {
                                        data.on_insert_RETWEET(X, X + i, *s, 2);
                                }
                                const auto start_time = std::chrono::steady_clock::now();
                                for( long i = 1; i <= MAX; ++i ) {
                                        //data.on_insert_RETWEET(X, X + i, *s, 2);
                                        data.on_delete_RETWEET(X, X + i, *s, 2);
                                }
                                double time_in_seconds = std::chrono::duration_cast<std::chrono::milliseconds> (std::chrono::steady_clock::now() - start_time).count();
                                std::cout << time_in_seconds<<"ms"<<std::endl;
                        }
        }
    };
}


/**
 * In order to compile this file one would have to include a header containing
 * the definition of "dbtoaster::Program" and "dbtoaster::Program::snapshot_t"
 * as generated by the dbtoaster C++ code generator. Using the "-c" dbtoaster
 * command line option the generated header file is automatically included and
 * compiled against this file.
 */

/**
 * Determines whether "--async" was specified as a command line argument.
 *
 * @param argc
 * @param argv
 * @return true if "--async" is one of the command line arguments
 */
bool async_mode(int argc, char* argv[])
{
    for(int i = 1; i < argc; ++i)
        if( !strcmp(argv[i],"--async") )
            return true;
    return false;
}

/**
 * Main function that executes the sql program corresponding to the header file
 * included. If "-async" is among the command line arguments then the execution
 * is performed asynchronous in a seperate thread, otherwise it is performed in
 * the same thread. If performed in a separate thread and while not finished it
 * continuously gets snapshots of the results and prints them in xml format. At
 * the end of the execution the final results are also printed.
 *
 * @param argc
 * @param argv
 * @return
 */
int main(int argc, char* argv[]) {
    bool async = async_mode(argc,argv);

    //dbtoaster::Program p;//(argc,argv);
    //dbtoaster::CustomProgram_1 p;
    dbtoaster::CustomProgram_2 p;
    //dbtoaster::Program::snapshot_t snap;
	dbtoaster::CustomProgram_2::snapshot_t snap;

    cout << "Initializing program:" << endl;
    p.init();
	
    p.run( async );

    cout << "Running program:" << endl;
    while( !p.is_finished() )
    {
       snap = p.get_snapshot();
       DBT_SERIALIZATION_NVP_OF_PTR(cout, snap);
    }

    cout << "Printing final result:" << endl;
    snap = p.get_snapshot();
    //DBT_SERIALIZATION_NVP_OF_PTR(cout, snap);
    cout << std::endl;
    return 0;
}

